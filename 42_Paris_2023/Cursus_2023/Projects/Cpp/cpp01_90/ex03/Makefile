# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    Makefile                                           :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: mechard <mechard@student.42.fr>            +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2024/08/22 13:47:46 by mechard           #+#    #+#              #
#    Updated: 2025/04/22 13:36:07 by mechard          ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

#======================================================
#                   VARIABLES
#======================================================

#------------------------------------------------------
# Variables globales
#------------------------------------------------------

PROJECT				= cpp01
NAME				= ex03
LANG				= c++

# R√©pertoires
INC_DIR				= inc
OBJ_DIR				= obj
EXEC_DIR			= exec

################################################################################
# Variables
################################################################################

# Globales
SRC					= $(shell find . -type f -not -path "./inc/*" | awk 'length($$0) >= 4 && substr($$0, length($$0)- length("$(SRC_EXT)") + 1, length("$(SRC_EXT)")) == "$(SRC_EXT)" { print }')
HDRS				= $(shell find . -type f -not -path "./inc/libft/inc/minilibx-linux/*" -not -path "./inc/minilibx-linux/*" | awk 'length($$0) >= 4 && substr($$0, length($$0)- length("$(HDR_EXT)") + 1, length("$(HDR_EXT)")) == "$(HDR_EXT)" { print }')
OBJS 				= $(patsubst %.c,%.o,$(notdir $(SRC)))
HDRS_LOCATION		= $(shell find . -type f | awk 'length($$0) >= 4 && substr($$0, length($$0)- length("$(HDR_EXT)") + 1, length("$(HDR_EXT)")) == "$(HDR_EXT)" { cmd="dirname "$$0; cmd | getline d; close(cmd); print d }' | sort -u)
HDRS_FLAG			= $(addprefix -I, $(HDRS_LOCATION))
SANITIZE			= -fsanitize=address -fsanitize=undefined
ALL					= $(SRC) $(HDRS)

# Libft
MLX_TITLE			= Minilibx
LINK_MLX			= https://cdn.intra.42.fr/document/document/31613/minilibx-linux.tgz
MLX_DIR				= $(addprefix $(INC_DIR)/, minilibx-linux)
MLX_A				= $(shell find . -type f -name "libmlx.a")
LIB					= libft.a
ifeq ($(MLX_A),)
	MLX_A = minilibx.a
endif
ifeq ($(LANG), c)
ifneq ($(PROJECT), LIBFT)
	LIB_DIR			= $(shell find inc -type d -name "libft")
	LIB_OBJ			= $(addprefix $(LIB_DIR)/, obj)
	LIB_INC			= $(addprefix $(LIB_DIR)/, inc)
	LIB_EXEC		= $(addprefix $(LIB_DIR)/, exec)
	LIB_A			= $(addprefix $(LIB_EXEC)/, libft.a)
else
	NAME			= $(addprefix exec/, $(LIB))
endif
endif

################################################################################
# Compilateur et options
################################################################################

ifeq ($(LANG), c++)
	CC				= c++
	SRC_EXT			= .cpp
	HDR_EXT			= .hpp
	CFLAGS			= -Wall -Wextra -Werror -std=c++98 -g3 #-fsanitize=address -fsanitize=undefined
	COMPI			= $(CC) $(CFLAGS) $(HDRS_FLAG) $(SRC) -o $(NAME)
else ifeq ($(LANG), c)
	CC				= cc
	SRC_EXT			= .c
	HDR_EXT			= .h
	CFLAGS			= -Wall -Wextra -Werror -g3 #-fsanitize=address -fsanitize=undefined
	LIBRARY			= -lreadline -lncurses -lXext -lX11 -lm -lXpm -pthread
	ifeq ($(PROJECT), LIBFT)
		COMPI		= $(CC) $(CFLAGS) $(HDRS_FLAG) $(LIBRARY) -c $(SRC)
	else ifeq ($(LIBFT_DIR),)
		COMPI		= $(CC) $(CFLAGS) $(HDRS_FLAG) $(SRC) $(MLX_A) $(LIB_A) $(LIBRARY) -o $(NAME)
	else
		COMPI		= $(CC) $(CFLAGS) $(HDRS_FLAG) $(SRC) $(LIBRARY) -o $(NAME)
	endif
endif

################################################################################
# Couleurs, symboles et autres variables d'affichage
################################################################################

# Reset & style
D_COLOR         = \033[0m
BOLD            = \033[1m

# Couleurs texte
BLACK1          = \033[30m
RED1            = \033[31m
GREEN1          = \033[32m
YELLOW1         = \033[33m
BLUE1           = \033[34m
PINK1           = \033[35m
CYAN1           = \033[36m
GREY1           = \033[37m

# Couleurs de fond
BLACK2          = \033[40m
RED2            = \033[41m
GREEN2          = \033[42m
YELLOW2         = \033[43m
BLUE2           = \033[44m
PINK2           = \033[45m
CYAN2           = \033[46m
GREY2           = \033[47m

# Symboles
SUCCESS         = ‚úÖ
TELECHARGEMENT  = üîΩüîÅ
DL_FINISH       = üîΩ‚úÖ
DELETED         = üí•
ERR				= ‚ÄºÔ∏è

# Autres variables
SILENCE         = > /dev/null 2>&1
M           	= make --no-print-directory -C
MAKE			= $(M) ./
LMAKE			= $(M) $(LIB_DIR)
FIN             = =================$(GREEN1)END$(D_COLOR)=================\n

################################################################################
# Variables d'affichage (pour les r√®gles begin et under_begin)
################################################################################

LINE_WIDTH      = 37
BLOCK_SIZE      = 21
END_SPACES      = 12

################################################################################
#                   R√àGLES PRINCIPALES
################################################################################

all: $(NAME)

#------------------------------------------------------
# Compilation de l'ex√©cutable
#------------------------------------------------------

$(NAME): $(ALL)
ifeq ($(filter-out all $(NAME), $(MAKECMDGOALS)), )
	@$(MAKE) begin ARG3="$(MAKECMDGOALS)"
endif

ifeq ($(PROJECT), LIBFT)
	@if [ ! -f $(MLX_A) ] || [ ! $(MLX_A) ]; then \
		$(MAKE) minilibx.a; \
	fi
	@mkdir -p $(OBJ_DIR)
	@-$(MAKE) under_begin ARG3="$(LIB)"
else
	@$(MAKE) under_begin ARG3=$(NAME)
endif
ifeq ($(LANG), c)
	@-$(MAKE) verif_norme
endif
ifeq ($(LANG), c)
	@if [ ! -f "$(LIB_A)" ] && [ -n $(LIBFT_DIR) ] && [ "$(PROJECT)" != "LIBFT" ]; then \
		$(LMAKE) all $(SILENCE); \
		$(MAKE) success ARG3="$(LIB)"; \
	fi
endif
	@-$(COMPI) > res_cmp
ifeq ($(PROJECT), LIBFT)
	@ar rcs $(LIB) $(OBJS) $(SILENCE)
	@mkdir -p $(EXEC_DIR)
	@ranlib $(LIB) $(SILENCE)
	@mv $(OBJS) $(OBJ_DIR)
	@mv $(LIB) $(EXEC_DIR)
endif
	@if [ ! -s res_cmp ]; then \
		rm -rf res_cmp; \
		if [ -s $(NAME) ]; then \
			$(MAKE) success ARG3="$(NAME)"; \
		fi; \
	elif [ -s res_cmp ]; then \
		$(MAKE) error_compi; \
	fi
	@$(MAKE) end

#------------------------------------------------------
# Nettoyage (fichiers temporaires)
#------------------------------------------------------

clean:
ifneq ($(filter-out $(COMPI),$(MAKECMDGOALS)),)
	@$(MAKE) begin ARG3="$(MAKECMDGOALS)"
endif
	@allowed="$(ALL) $(OBJS) $(NAME) Makefile Makefile_OLD"; \
	deleted=0; \
	if [ -d "$(LIB_OBJ)" ]; then \
		$(MAKE) under_begin ARG3="CLEAN"; \
		deleted=1; \
		$(LMAKE) clean $(SILENCE); \
		$(MAKE) suppr_line ARG3=".o dans libft"; \
	fi; \
	for file in $$(find . -type f -not -path "./src/*" -not -path "./inc/*" -not -path "./exec/*" -not -path "./obj/*" -not -path "./map/*" -not -name ".gitignore"); do \
		keep=no; \
		for a in $$allowed; do \
			if [ "$$file" = "$$a" ] || [ "$$file" = "./$$a" ]; then \
				keep=yes; \
			fi; \
		done; \
		if [ "$$keep" = "no" ]; then \
			if [ $$deleted -eq 0 ]; then \
				$(MAKE) under_begin ARG3="CLEAN"; \
				deleted=1; \
			fi; \
			rm -f $$file; \
			$(MAKE) suppr_line ARG3=$$file; \
		fi; \
	done; \
	if [ -d $(OBJ_DIR) ]; then \
		if [ $$deleted -eq 0 ]; then \
			$(MAKE) under_begin ARG3="CLEAN"; \
			deleted=1; \
		fi; \
		rm -rf $(OBJ_DIR); \
		$(MAKE) suppr_line ARG3="$(OBJ_DIR)"; \
	fi; \
	for dir in $$(find . -type f -name "*.o" -not -path "./src/*" -not -path "./inc/*" -not -path "./exec/*" -exec dirname {} \; | sort -u); do \
	    if [ "$$dir" != "." ]; then \
		    rm -rf $$dir; \
		    $(MAKE) suppr_line ARG3="Directory $$dir"; \
	    fi; \
	done; \
	if [ "$(MAKECMDGOALS)" != "clean" ] && [ $$deleted -eq 1 ]; then \
		printf "|                                   |\n"; \
	fi; \
	if [ $$deleted -eq 0 ]; then \
		echo "|Nothing to be done for 'clean'     |"; \
		if [ -f "$(NAME)" ]; then \
			printf "|                                   |\n"; \
		fi; \
	fi
ifeq ($(MAKECMDGOALS), clean)
	@$(MAKE) end
endif



#------------------------------------------------------
# Nettoyage complet (ex√©cutable, etc.)
#------------------------------------------------------

fclean: clean
	@if [ -f "$(NAME)" ]; then \
		$(MAKE) under_begin ARG3="FCLEAN"; \
		if [ -d "$(LIB_EXEC)" ]; then \
			rm -rf $(LIB_EXEC); \
			$(MAKE) suppr_line ARG3="$(LIB_EXEC)"; \
		fi; \
		if [ -f "$(NAME)" ]; then \
			rm -rf $(NAME) $(SILENCE); \
			$(MAKE) suppr_line ARG3=$(NAME); \
		fi; \
		if [ -d "$(MLX_DIR)" ]; then \
			rm -rf $(MLX_DIR); \
			$(MAKE) suppr_line ARG3="$(MLX_DIR)"; \
		fi; \
		if [ -d "$(EXEC_DIR)" ]; then \
			rm -rf $(EXEC_DIR); \
			$(MAKE) suppr_line ARG3="$(EXEC_DIR)"; \
		fi; \
		if [ "$(MAKECMDGOALS)" != "fclean" ]; then \
			echo "|                                   |"; \
		fi; \
	else \
		echo "|Nothing to be done for 'fclean'    |"; \
		if [ $(MAKECMDGOALS) != "fclean" ]; then \
			echo "|                                   |"; \
		fi; \
	fi
ifeq ($(MAKECMDGOALS), fclean)
	@$(MAKE) end
endif

#------------------------------------------------------
# Recompilation totale
#------------------------------------------------------

re: fclean all

################################################################################
#                 AUTRES R√àGLES
################################################################################

#------------------------------------------------------
# Compilation de la minilibx
#------------------------------------------------------

$(MLX_A):
	@$(MAKE) under_begin ARG3="Minilibx"
	@echo "|$(PINK1)T√©l√©chargement de la mlx$(D_COLOR)     : $(TELECHARGEMENT)|"
	@mkdir -p $(MLX_DIR)
	@curl -o $(INC_DIR)/minilibx-linux.tgz $(LINK_MLX) $(SILENCE)
	@tar -xzvf $(INC_DIR)/minilibx-linux.tgz -C $(INC_DIR) $(SILENCE)
	@rm $(INC_DIR)/minilibx-linux.tgz
	@echo "\033[1A\033[2K|$(GREEN1)Minilibx telecharg√©$(D_COLOR)          : $(DL_FINISH)|"
	@$(M) $(MLX_DIR) all $(SILENCE)
	@$(MAKE) success ARG3="./minilibx"
	@printf "|                                   |\n"

#------------------------------------------------------
# R√®gle de v√©rification de la norme 42
#------------------------------------------------------

verif_norme :
	-@norminette $(SRC) > res_cmd || true
	-@grep 'Error' res_cmd > norminette || true
	-@norminette $(HDRS) > res_cmd || true
	-@grep "Error" res_cmd >> norminette || true
	@rm res_cmd
	@if [ ! -s norminette ]; then \
    	rm norminette; \
		$(MAKE) success ARG3="norme de $(NAME)"; \
	else \
   		$(MAKE) suppr_line ARG3="norme de $(NAME)"; \
	fi

#------------------------------------------------------
# R√®gle d'affichage "begin"
# Affiche 37 caract√®res : "=" + bloc central (35) + "="
# Tronque ARG3 (34 + ".") si > 35, " " => "\" \"", 
# puis on centre
#------------------------------------------------------

begin:
	@if [ -z "$(ARG3)" ]; then \
		upper_arg3="\" \""; \
	elif [ "$(ARG3)" = " " ]; then \
		upper_arg3="\" \""; \
	else \
		upper_arg3=$$(echo "$(ARG3)" | tr '[:lower:]' '[:upper:]'); \
	fi; \
	arg_len=$$(echo -n "$$upper_arg3" | wc -c); \
	if [ $$arg_len -gt 35 ]; then \
		truncated_arg3=$$(echo -n "$$upper_arg3" | cut -c1-34).; \
		printf "\n="; \
		printf "$(PINK1)$$truncated_arg3$(D_COLOR)"; \
		printf "=\n|                                   |\n"; \
	else \
		leftover=$$(( 35 - arg_len )); \
		left_equals=$$(( leftover / 2 )); \
		right_equals=$$(( leftover - left_equals )); \
		printf "\n="; \
		for _ in $$(seq 1 $$left_equals); do printf "="; done; \
		printf "$(PINK1)$$upper_arg3$(D_COLOR)"; \
		for _ in $$(seq 1 $$right_equals); do printf "="; done; \
		printf "=\n|                                   |\n"; \
	fi
	@-$(MAKE) under_begin ARG3="$(PROJECT)"
	@-$(MAKE) under_begin ARG3="$(LANG)"

#------------------------------------------------------
# R√®gle d'affichage "under_begin"
# Affiche une ligne de 37 caract√®res :
# |  + bloc central de 21 caract√®res + 12 espaces + |
# Bloc central : si ARG3 > 19 caract√®res, on tronque √† 18 caract√®res et on ajoute un point.
# Sinon, on centre ARG3 en entourant de '=' pour atteindre 21 caract√®res.
#------------------------------------------------------

under_begin:
	@if [ -z "$(ARG3)" ]; then \
		upper_arg3=" "; \
	else \
		upper_arg3=$$(echo "$(ARG3)" | tr '[:lower:]' '[:upper:]'); \
	fi; \
	upper_project=$$(echo "$(PROJECT)" | tr '[:lower:]' '[:upper:]'); \
	upper_lang=$$(echo "$(LANG)" | tr '[:lower:]' '[:upper:]'); \
	if [ "$$upper_arg3" = "$$upper_project" ] || [ "$$upper_arg3" = "$$upper_lang" ]; then \
	    block_size=31; \
	    spaces_after=2; \
		color=$(BLUE1); \
	else \
	    block_size=21; \
	    spaces_after=12; \
		color=$(YELLOW1); \
	fi; \
	arg_len=$$(echo -n "$$upper_arg3" | wc -c); \
	printf "|  "; \
	threshold=$$(( block_size - 2 )); \
	if [ $$arg_len -gt $$threshold ]; then \
	    truncated_arg3=$$(echo -n "$$upper_arg3" | cut -c1-$$(( block_size - 3 ))).; \
	    printf "=%s=" "\\$$color$$truncated_arg3$(D_COLOR)"; \
	else \
	    leftover=$$(( block_size - arg_len )); \
	    left_equals=$$(( leftover / 2 )); \
	    right_equals=$$(( leftover - left_equals )); \
	    for _ in $$(seq 1 $$left_equals); do printf "="; done; \
	    printf "\\$$color$$upper_arg3$(D_COLOR)"; \
	    for _ in $$(seq 1 $$right_equals); do printf "="; done; \
	fi; \
	for _ in $$(seq 1 $$spaces_after); do printf " "; done; \
	if [ "$$upper_arg3" != "$$upper_project" ]; then \
	    printf "|\n|                                   "; \
	fi; \
	printf "|\n";

#------------------------------------------------------
# R√®gle d'affichage "suppr_line"
# Affiche une ligne de 37 caract√®res contenant ARG3 ajust√©
# sur 29 caract√®res (tronqu√© ou compl√©t√©) suivi de " : üí•  "
# pour signaler la suppression d'un fichier.
#------------------------------------------------------

suppr_line:
	@{ \
		if [ -z "$(ARG3)" ]; then \
			display_arg3="\" \""; \
		else \
			display_arg3="$(ARG3)"; \
		fi; \
		arg_len=$$(echo -n "$$display_arg3" | wc -c); \
		if [ $$arg_len -gt 28 ]; then \
			truncated=$$(echo -n "$$display_arg3" | cut -c1-25); \
			field="$$truncated..."; \
		else \
			field="$$display_arg3"; \
			pad=$$((28 - arg_len)); \
			i=1; \
			while [ $$i -le $$pad ]; do \
				field="$$field "; \
				i=$$(( i + 1 )); \
			done; \
		fi; \
		if [ "$$(echo "$(ARG3)" | cut -c1-5)" = "norme" ]; then \
    		deleted_symbol=" $(ERR)"; \
		else \
    		deleted_symbol="$(DELETED)"; \
		fi; \
		printf "|$(RED2)%s$(D_COLOR) : %s  |\n" "$$field" "$$deleted_symbol"; \
	}

#------------------------------------------------------
# R√®gle d'affichage "success"
# Affiche une ligne de 37 caract√®res contenant ARG3 ajust√©
# sur 29 caract√®res (tronqu√© ou compl√©t√©) suivi de " : ‚úÖ  "
# pour signaler la suppression d'un fichier.
#------------------------------------------------------

success :
	@{ \
		if [ -z "$(ARG3)" ]; then \
			display_arg3="\" \""; \
		else \
			display_arg3="$(ARG3)"; \
		fi; \
		arg_len=$$(echo -n "$$display_arg3" | wc -c); \
		if [ $$arg_len -gt 28 ]; then \
			truncated=$$(echo -n "$$display_arg3" | cut -c1-25); \
			field="$$truncated..."; \
		else \
			field="$$display_arg3"; \
			pad=$$((28 - arg_len)); \
			i=1; \
			while [ $$i -le $$pad ]; do \
				field="$$field "; \
				i=$$(( i + 1 )); \
			done; \
		fi; \
		printf "|%s$(D_COLOR) : $(SUCCESS)  |\n" "$$field"; \
	}

#------------------------------------------------------
# R√®gle d'affichage "end"
#------------------------------------------------------

end:
	@printf "|                                   |\n"
	@echo "$(FIN)"

################################################################################
#              R√àGLES PHONY (obligatoires)
################################################################################

.PHONY: all clean fclean re begin under_begin suppr_line end